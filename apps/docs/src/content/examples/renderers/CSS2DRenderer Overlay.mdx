This example shows how to run an additional Three.js renderer in parallel with Threlte's `<Canvas>`, while still leveraging Threlte's built-in elements. Specifically, we'll run [CSS2DRenderer](https://threejs.org/docs/index.html#examples/en/renderers/CSS2DRenderer) to add flat labels to objects in a three-dimensional scene.

This example can be easily adapted to use [CSS3DRenderer](https://threejs.org/docs/index.html#examples/en/renderers/CSS3DRenderer) instead, if you want the elements to live "inside" the scene, rather than flat across the surface.

<Example path="renderers/CSS2DRenderer" />

## How does it work?

In this scene, we run two renderers - the default one provided by Threlte, and a new CSS2DRenderer which we initialize manually. Threlte's renderer runs on a canvas element as normal, while our new renderer runs in a `<div>` with absolute positioning on top of it.

### The render loop

To integrate the a new renderer into svelte's loop, we call it inside `useRender()` after the tick.

By default, each rendrer traverses the scene and updates every object. We can set [scene.matrixWorldAutoUpdate](https://threejs.org/docs/#api/en/core/Object3D.matrixAutoUpdate) to false and manually call `scene.updateMatrixWorld()` each tick in order to avoid duplicating the work, since we're running two renderers.

```svelte title="Scene.svelte"
<script>
  const { scene, size } = useThrelte()

  // Set up the CSS2DRenderer to run in a div placed atop the <Canvas>
  const element = document.querySelector('#css-renderer-target')
  const cssRenderer = new CSS2DRenderer({ element })
  $: cssRenderer.setSize($size.width, $size.height)

  // Tell ThreeJS renderers not to call scene.updateMatrixWorld() with every
  // render. Since we're running two renderers, this would result in double
  // updates.
  scene.matrixWorldAutoUpdate = false

  useRender(async ({ renderer, scene, camera }) => {
    // 1. Flush any pending svelte changes and element updates, especially tweening.
    // https://svelte.dev/tutorial/tick
    await tick()

    // 2. Tell ThreeJS to update the state of its components based on this new information.
    // Normally this happens as part of a .render() call, but we set matrixWorldAutoUpdate = false
    // in order to avoid both render calls triggering it.
    // https://threejs.org/docs/#api/en/core/Object3D.updateWorldMatrix
    scene.updateMatrixWorld()

    // 3. Tell both renderers to update the canvas and DOM elements on screen.
    renderer.render(scene, camera.current)
    cssRenderer.render(scene, camera.current)
  })
</script>
```

### Setting up CssObject

The other integral part is a component that accepts DOM contents in the default slot and places them in the scene and renders them with the ThreeJS `CSS2DRenderer`:

```svelte title="CssObject.svelte"
<script>
  import { T } from '@threlte/core'
  import { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer'

  export let pointerEvents = false

  let element

  const cssobject = (node) => {
    element = node
    return {
      destroy() { element = undefined }
    }
  }
</script>

<div
  use:cssobject
  style:pointer-events={pointerEvents ? 'auto' : 'none !important'}
  style:will-change="transform"
>
  <slot />
</div>

{#if element}
  <T {...$$restProps} is={CSS2DObject} args={[element]} let:ref>
    <slot name="three" {ref} />
  </T>
{/if}
```

This component renders children into a div, and hooks that into Threlte's internals by using `<T is={CSS2DObject}>`. It passes all other properties through, letting us use it like so:

```svelte

<CssObject position={[-1, 2, 1]} center={[0, 0.5]}>
  <button on:click={clickHello}>
    Hello - {helloCount}
  </button>
</CssObject>
```
