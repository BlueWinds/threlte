---
{
  category: '@threlte/xr',
  name: 'pointerControls',
  order: 3,
  type: 'plugin'
}
---

The `pointerControls` plugin adds pointer events to an immersive XR session. This means that pointing at any mesh with your hand or a controller will trigger DOM-like pointer events.

To get started, import and call the plugin in a component within your app.

```svelte
<script>
  import { pointerControls } from '@threlte/xr'
  pointerControls()
</script>
```

Any mesh **within this component and all child components** will now receive events if a controller or hand points at it.

```svelte
<T.Mesh
  on:click={() => {
    console.log('clicked')
  }}
>
  <T.BoxGeometry />
  <T.MeshStandardMaterial color="red" />
</T.Mesh>
```

### Available Events

The following events are available:

```svelte
<T.Mesh
  on:click={(e) => console.log('click')}
  on:contextmenu={(e) => console.log('context menu')}
  on:pointerup={(e) => console.log('up')}
  on:pointerdown={(e) => console.log('down')}
  on:pointerover={(e) => console.log('over')}
  on:pointerout={(e) => console.log('out')}
  on:pointerenter={(e) => console.log('enter')}
  on:pointerleave={(e) => console.log('leave')}
  on:pointermove={(e) => console.log('move')}
/>
```

While a controller or hand is pointed at this mesh...

* `click` fires when a user selects the primary action input. This usually means pulling a primary trigger with a controller or pinching with a hand.
* `contextmenu` fires when a user selects and holds the primary action input for more than 2 seconds.
* `pointerdown` fires when a primary action begins, and `pointerup` fires when it ends.
* `pointerover` and `pointerout` fire when the ray of the pointing device is moved onto an object, or onto one of its children. It bubbles, meaning it can trigger on the object that the pointer is over or any of its ancestor objects.
* `pointerenter` and `pointerleave` fire when the ray of the pointing device enters / leaves the boundaries of an object, and does not bubble. It only triggers on the exact element the pointer has entered / left.

To replace the default ray and cursor that are created by the plugin, the following slots can be added to a `<Controller>` or a `<Hand>`:

```svelte
<script>
  import { Hand, Controller } from '@threlte/xr'
  import CustomRay from './CustomRay.svelte'
  import CustomCursor from './CustomCursor.svelte'
</script>

<Controller left>
  <CustomRay slot='pointer-ray'>
  <CustomCursor slot='pointer-cursor'>
</Controller>

<Hand left>
  <CustomRay slot='pointer-ray'>
  <CustomCursor slot='pointer-cursor'>
</Hand>
```

This plugin can be composed with the `teleportControls` plugin to allow both teleporting and interaction.

```svelte
<script>
  import { pointerControls, teleportControls } from '@threlte/xr'
  pointerControls()
  teleportControls()
</script>
```

This will result in `pointerControls` taking over when pointing at a mesh with events, and `teleportControls` taking over otherwise.

It can also be composed with `interactivity` to allow pointer events within and outside an immersive session.

```svelte
<script>
  import { interactivity } from '@threlte/extras'
  import { pointerControls, teleportControls } from '@threlte/xr'
  interactivity()
  pointerControls()
</script>
```

The will be a few subtle differences when events are fired within an immersive session:

* Pointers / cursors will be `THREE.Vector3`s instead of `THREE.Vector2`s. In XR, the cursor that intersects with the object that you interact with can be anywhere within a 3d space.
* There will be no `camera` property on the event, since raycasting will originate from hands or controllers.
* The `nativeEvent` property on event objects will be a `XRControllerEvent` or `XRHandEvent` rather than a `DomEvent`.

<Example path="xr/pointer-controls" />
